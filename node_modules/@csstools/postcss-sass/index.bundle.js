'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var sourceMap = require('source-map');
var postcss = _interopDefault(require('postcss'));
var sassResolve = _interopDefault(require('@csstools/sass-import-resolve'));
var sass = _interopDefault(require('node-sass'));
var path = require('path');

// tooling
// special sass source matcher
var sassMatch = /#sass$/;

// returns merged source maps
function mergeSourceMaps () {
	// new sourcemap
	var generator = new sourceMap.SourceMapGenerator();

	// existing sourcemaps

	for (var _len = arguments.length, maps = Array(_len), _key = 0; _key < _len; _key++) {
		maps[_key] = arguments[_key];
	}

	var consumers = maps.map(function (map) {
		return new sourceMap.SourceMapConsumer(map);
	});

	consumers.forEach(function (consumer) {
		// copy each original mapping to the new sourcemap
		consumer.eachMapping(function (mapping) {
			var originalPosition = originalPositionFor(mapping, consumers);

			if (originalPosition.source) {
				generator.addMapping({
					generated: {
						line: mapping.generatedLine,
						column: mapping.generatedColumn
					},
					original: {
						// use positive numbers to work around sass/libsass#2312
						line: Math.abs(originalPosition.line),
						column: Math.abs(originalPosition.column)
					},
					source: originalPosition.source,
					name: originalPosition.name
				});
			}
		});

		// copy each original source to the new sourcemap
		consumer.sources.forEach(function (source) {
			generator._sources.add(source);

			var content = consumer.sourceContentFor(source);

			if (content !== null) {
				generator.setSourceContent(source, content);
			}
		});
	});

	// merged map as json
	var mergedMap = JSON.parse(generator);

	// clean all special sass sources in merged map
	mergedMap.sources = mergedMap.sources.map(function (source) {
		return source.replace(sassMatch, '');
	});

	return mergedMap;
}

function originalPositionFor(mapping, consumers) {
	// initial positioning
	var originalPosition = {
		line: mapping.generatedLine,
		column: mapping.generatedColumn
	};

	// special sass sources are mapped in reverse
	consumers.slice(0).reverse().forEach(function (consumer) {
		var possiblePosition = consumer.originalPositionFor(originalPosition);

		if (possiblePosition.source) {
			if (sassMatch.test(possiblePosition.source)) {
				originalPosition = possiblePosition;
			}
		}
	});

	// regular sources are mapped regularly
	consumers.forEach(function (consumer) {
		var possiblePosition = consumer.originalPositionFor(originalPosition);

		if (possiblePosition.source) {
			if (!sassMatch.test(possiblePosition.source)) {
				originalPosition = possiblePosition;
			}
		}
	});

	return originalPosition;
}

// tooling
// transform css with sass
var index = postcss.plugin('postcss-sass', function (opts) {
	return function (root, result) {
		// postcss configuration
		var postConfig = Object.assign({}, result.opts, requiredPostConfig);

		// postcss results

		var _root$toResult = root.toResult(postConfig),
		    postCSS = _root$toResult.css,
		    postMap = _root$toResult.map;

		// include paths


		var includePaths = [].concat(opts && opts.includePaths || []);

		// sass resolve cache
		var cache = {};

		return new Promise(
		// promise sass results
		function (resolve$$1, reject) {
			return sass.render(
			// pass options directly into node-sass
			Object.assign({}, opts, requiredSassConfig, {
				file: `${postConfig.from}#sass`,
				outFile: postConfig.from,
				data: postCSS,
				importer(id, parentId, done) {
					// resolve the absolute parent
					var parent = path.resolve(parentId);

					// cwds is the list of all directories to search
					var cwds = [path.dirname(parent)].concat(includePaths).map(function (includePath) {
						return path.resolve(includePath);
					});

					cwds.reduce(
					// resolve the first available files
					function (promise, cwd) {
						return promise.catch(function () {
							return sassResolve(id, { cwd, cache, readFile: true });
						});
					}, Promise.reject()).then(function (_ref) {
						var file = _ref.file,
						    contents = _ref.contents;

						// push the dependency to watch tasks
						result.messages.push({ type: 'dependency', file, parent });

						// pass the file and contents back to sass
						done({ file, contents });
					}, function (importerError) {
						// otherwise, pass the error
						done(importerError);
					});
				}
			}), function (sassError, sassResult) {
				return sassError ? reject(sassError) : resolve$$1(sassResult);
			});
		}).then(function (_ref2) {
			var sassCSS = _ref2.css,
			    sassMap = _ref2.map;

			// update root to post-node-sass ast
			result.root = postcss.parse(sassCSS.toString(), Object.assign({}, postConfig, {
				map: {
					prev: mergeSourceMaps(postMap.toJSON(), JSON.parse(sassMap))
				}
			}));
		});
	};
});

var requiredPostConfig = {
	map: {
		annotation: false,
		inline: false,
		sourcesContent: true
	}
};

var requiredSassConfig = {
	omitSourceMapUrl: true,
	sourceMap: true,
	sourceMapContents: true
};

module.exports = index;
