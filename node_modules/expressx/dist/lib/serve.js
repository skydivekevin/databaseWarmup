'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.initialTranspile = initialTranspile;
exports.cleanupStatic = cleanupStatic;
exports.copyJsonFiles = copyJsonFiles;
exports.handleWebpackError = handleWebpackError;
exports.handleStylesError = handleStylesError;
exports.handleBabelError = handleBabelError;

var _path = require('path');

var _glob = require('glob');

var _glob2 = _interopRequireDefault(_glob);

var _fbWatchman = require('fb-watchman');

var _fbWatchman2 = _interopRequireDefault(_fbWatchman);

var _fsExtra = require('fs-extra');

var _fsExtra2 = _interopRequireDefault(_fsExtra);

var _logSymbols = require('log-symbols');

var _logSymbols2 = _interopRequireDefault(_logSymbols);

var _chalk = require('chalk');

var _chalk2 = _interopRequireDefault(_chalk);

var _ora = require('ora');

var _ora2 = _interopRequireDefault(_ora);

var _del = require('del');

var _del2 = _interopRequireDefault(_del);

var _startProcess = require('./start-process');

var _startProcess2 = _interopRequireDefault(_startProcess);

var _livereload = require('./livereload');

var _livereload2 = _interopRequireDefault(_livereload);

var _transpile = require('./transpile');

var _transpile2 = _interopRequireDefault(_transpile);

var _postcss = require('./postcss');

var _postcss2 = _interopRequireDefault(_postcss);

var _webpack = require('./webpack');

var _webpack2 = _interopRequireDefault(_webpack);

var _config = require('./config');

var _config2 = _interopRequireDefault(_config);

var _utils = require('./utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/* eslint-disable global-require, import/no-dynamic-require, security/detect-non-literal-require */
var cwd = process.cwd();

/**
 * Perform initial transpilation
 *
 * @returns {Promise}
 */
function initialTranspile() {
	return new Promise(function (resolve, reject) {
		(0, _glob2.default)((0, _path.join)(cwd, '**/*.js'), {
			ignore: [(0, _path.join)(cwd, 'node_modules/**/*.js'), (0, _path.join)(cwd, 'dist/**/*.js'), (0, _path.join)(cwd, _config2.default.staticFolder + '/**/*.js'), (0, _path.join)(cwd, '.expressx/**/*.js'), (0, _path.join)(cwd, 'expressx.config.js'), (0, _path.join)(cwd, 'flow-typed/**/*.js'), (0, _path.join)(cwd, '**/__tests__/**/*.js'), (0, _path.join)(cwd, '**/coverage/**/*.js')].concat(_toConsumableArray(_config2.default.babel.ignore.map(function (g) {
				return (0, _path.join)(cwd, g);
			})))
		}, async function (err, files) {
			if (err) {
				console.error(_chalk2.default.bgRed.black(' ERROR '), _chalk2.default.red("Oops, a weird error just happened and we weren't prepared for it:\n"), err);
				reject();
			} else {
				// Basically async forEach before resolving
				// eslint-disable-next-line promise/no-promise-in-callback
				await Promise.all(files.map(async function (file) {
					try {
						await (0, _transpile2.default)(file, true);
					} catch (e) {
						reject(e);
					}
				}));
				resolve();
			}
		});
	});
}

/**
 * Check if watched file is designated for webpack
 *
 * @param {string} file - Flie path
 * @param {string} webpackEntries - Webpack paths
 * @returns {boolean}
 */
function checkWebpackPaths(file, webpackEntries) {
	var includes = false;
	webpackEntries.forEach(function (entry) {
		var compare = Array.isArray(entry) ? entry[0] : entry;
		if (file.includes(compare.slice(2))) {
			// Trim the ./
			includes = true;
		}
	});

	return includes;
}

function cleanupStatic() {
	return new Promise(function (resolve, reject) {
		(0, _glob2.default)((0, _path.join)(cwd, '.expressx/**/*.scss'), async function (err, files) {
			// eslint-disable-next-line promise/no-promise-in-callback
			await Promise.all(files.map(async function (file) {
				try {
					await _fsExtra2.default.remove(file);
				} catch (e) {
					reject(e);
				}
			}));
			resolve();
		});
	});
}

function copyJsonFiles() {
	return new Promise(function (resolve, reject) {
		(0, _glob2.default)((0, _path.join)(cwd, '**/*.json'), {
			ignore: [(0, _path.join)(cwd, 'node_modules/**/*.json'), (0, _path.join)(cwd, 'coverage/**/*.json'), (0, _path.join)(cwd, '.expressx/**/*.json'), (0, _path.join)(cwd, 'jsconfig.json'), (0, _path.join)(cwd, 'tsconfig.json')]
		}, async function (err, files) {
			if (err) {
				reject(err);
			} else {
				// Basically async forEach before resolving
				// eslint-disable-next-line promise/no-promise-in-callback
				await Promise.all(files.map(async function (file) {
					try {
						await _fsExtra2.default.copy(file, file.replace(cwd, (0, _path.join)(cwd, '.expressx/build')));
					} catch (e) {
						reject(e);
					}
				}));
				resolve();
			}
		});
	});
}

/**
 * Handle webpack bundling error
 *
 * @param {any} e - error object
 */
async function handleWebpackError(e) {
	if (e.errors) {
		console.log(_chalk2.default.bgGreen.black(' ERROR '), _chalk2.default.red.bold('\nWebpack encountered ' + _chalk2.default.underline(e.errors.length) + ' error(s):'));
		e.errors.forEach(function (err) {
			return console.error('\n' + _logSymbols2.default.error, '' + err);
		});
	} else {
		console.error(_chalk2.default.bgRed.black(' ERROR '), _chalk2.default.red('\n' + e));
	}
}

/**
 * Handle PostCSS bundling error
 *
 * @param {any} e - error object
 */
async function handleStylesError(e) {
	console.error(_chalk2.default.bgRed.black(' ERROR '), _chalk2.default.red('Error when processing styles: \n'));
	console.log(e.toString());
}

/**
 * Handle Babel transpilation error
 *
 * @param {any} e - error object
 */
async function handleBabelError(e) {
	console.error(_chalk2.default.bgRed.black(' ERROR '), _chalk2.default.red('Babel encountered an error:'));
	if (e.codeFrame) {
		console.log(_chalk2.default.red(e.toString()));
		console.log(e.codeFrame);
	} else {
		console.log(e);
	}
}

/**
 * Main function
 *
 * @export
 */

exports.default = async function serve(_ref) {
	var debug = _ref.debug;

	var jsGlobs = ['**/*.js',
	// hbs, scss
	'!' + _config2.default.staticFolder + '/*.js', '!' + _config2.default.staticFolder + '/**/*.js', '!node_modules/**', '!dist/**', '!.expressx/**', '!flow-typed/**', '!__tests__/**', '!**/*.test.js', '!coverage/**', '!**/*.config.js'].concat(_toConsumableArray(_config2.default.watchmanIgnore.map(function (g) {
		return '!' + g;
	})));

	(0, _utils.clear)();
	var spinner = (0, _ora2.default)('Warming up...').start();

	// Remove previous build completely before production build
	if (process.env.NODE_ENV === 'production') {
		(0, _del2.default)((0, _path.join)(cwd, '.expressx/build'));
	}

	// Initial transpile and setup
	try {
		await initialTranspile();
	} catch (e) {
		spinner.stop();
		handleBabelError(e);
	}

	var ignoredFiles = [];
	if (process.env.NODE_ENV !== 'production' && _config2.default.babel.ignore.length > 0) {
		spinner.text = 'This might take a few moments...';
		_config2.default.babel.ignore.forEach(function (g) {
			ignoredFiles = [].concat(_toConsumableArray(ignoredFiles), _toConsumableArray(_glob2.default.sync((0, _path.join)(cwd, g))));
		});
	}

	try {
		await (0, _postcss2.default)();
	} catch (e) {
		handleStylesError(e);
	}
	if (_config2.default.webpackMode === 'direct') {
		try {
			if (!_config2.default.disableWebpack) await (0, _webpack2.default)();
		} catch (e) {
			handleWebpackError(e);
		}
	}

	await _fsExtra2.default.copy((0, _path.join)(cwd, _config2.default.staticFolder), (0, _path.join)(cwd, '.expressx/build/' + _config2.default.staticFolder));

	await copyJsonFiles();
	await cleanupStatic();

	// Start process and stop the spinner
	var proc = (0, _startProcess2.default)({ debug: debug });
	spinner.stop();

	var webpackEntries = [];

	// // File change handler
	async function handleWatchFile(file) {
		if (file.includes('.scss')) {
			try {
				await (0, _postcss2.default)();
				console.log(_chalk2.default.grey('> Styles processed successfully'));
				(0, _livereload2.default)();
			} catch (e) {
				handleStylesError(e);
			}
		}
		if (file.includes('.hbs')) {
			if (file.includes(_config2.default.hbs.partials)) {
				(0, _utils.clear)();
				proc.removeAllListeners('close');
				proc.kill();
				proc = (0, _startProcess2.default)({ debug: debug });
			} else {
				(0, _livereload2.default)();
			}
		}
		if (file.includes('.js') || file.includes('.jsx')) {
			if (checkWebpackPaths(file, webpackEntries) && !_config2.default.disableWebpack) {
				// If file is designated for webpack
				try {
					var webpackStats = await (0, _webpack2.default)();
					console.log(_chalk2.default.grey('> Webpack build ' + webpackStats.hash + ' finished in ' + webpackStats.time + 'ms'));
					(0, _livereload2.default)();
				} catch (e) {
					handleWebpackError(e);
				}
			} else if (!ignoredFiles.includes((0, _path.join)(cwd, file))) {
				(0, _utils.clear)();
				try {
					//                                    This is dirty -_-
					await (0, _transpile2.default)((0, _path.join)(cwd, file.replace(cwd.split('/')[cwd.split('/').length - 1], '')));
					proc.removeAllListeners('close');
					proc.kill();
					proc = (0, _startProcess2.default)({ debug: debug });
				} catch (e) {
					handleBabelError(e);
				}
			}

			// If transpilation by Babel is intended for webpack paths
			if (checkWebpackPaths(file, webpackEntries) && _config2.default.babelIncludeWebpackPaths && !ignoredFiles.includes((0, _path.join)(cwd, file))) {
				try {
					//                                    This is dirty -_-
					await (0, _transpile2.default)((0, _path.join)(cwd, file.replace(cwd.split('/')[cwd.split('/').length - 1], '')));
					proc.removeAllListeners('close');
					proc.kill();
					proc = (0, _startProcess2.default)({ debug: debug });
				} catch (e) {
					handleBabelError(e);
				}
			}
		}
	}

	// Set up watchers for development
	if (process.env.NODE_ENV !== 'production') {
		if (typeof _webpack.webpackConfig.entry === 'string') {
			webpackEntries.push(_webpack.webpackConfig.entry);
		} else {
			// eslint-disable-next-line security/detect-object-injection
			webpackEntries = Object.keys(_webpack.webpackConfig.entry).map(function (key) {
				return _webpack.webpackConfig.entry[key];
			});
		}

		var client = new _fbWatchman2.default.Client();
		client.capabilityCheck({
			optional: [],
			required: ['relative_root']
		}, function (error) {
			if (error) {
				console.log(_chalk2.default.bgRed.black(' ERROR '), error);
				client.end();
				return;
			}

			// Initiate the watch
			client.command(['watch-project', cwd], function (err, res) {
				if (err) {
					console.error(_chalk2.default.bgRed.black(' ERROR '), 'Error initiating watch:', err);
					return;
				}

				if ('warning' in res) {
					console.log(_chalk2.default.bgYellow.black(' WARN '), res.warning);
				}

				var jsSub = {
					expression: ['allof'].concat(_toConsumableArray(jsGlobs.map(function (watchglob) {
						return watchglob.includes('!') ? ['not', ['match', watchglob.replace('!', ''), 'wholename']] : ['match', watchglob, 'wholename'];
					}))),
					fields: ['name', 'size', 'mtime_ms', 'exists', 'type']
				};
				var hbsSub = {
					expression: ['anyof', ['match', _config2.default.hbs.views + '/*.hbs', 'wholename'], ['match', _config2.default.hbs.views + '/**/*.hbs', 'wholename']],
					fields: ['name', 'size', 'mtime_ms', 'exists', 'type']
				};
				var scssSub = {
					expression: ['anyof', ['match', '*.scss', 'wholename'], ['match', '**/*.scss', 'wholename']],
					fields: ['name', 'size', 'mtime_ms', 'exists', 'type']
				};

				client.command(['subscribe', res.watch, 'expressx:js', jsSub], function (e) {
					if (e) {
						console.error(_chalk2.default.bgRed.black(' ERROR '), 'failed to subscribe: ', e);
					}
				});
				client.command(['subscribe', res.watch, 'expressx:hbs', hbsSub], function (e) {
					if (e) {
						console.error(_chalk2.default.bgRed.black(' ERROR '), 'failed to subscribe: ', e);
					}
				});
				client.command(['subscribe', res.watch, 'expressx:scss', scssSub], function (e) {
					if (e) {
						console.error(_chalk2.default.bgRed.black(' ERROR '), 'failed to subscribe: ', e);
					}
				});

				client.on('subscription', function (resp) {
					if (!resp.is_fresh_instance) {
						resp.files.forEach(function (file) {
							handleWatchFile(file.name);
						});
					}
				});
			});
		});
	}
};